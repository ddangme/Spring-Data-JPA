# 목차
🎀 [메소드 이름으로 쿼리 생성](#메소드-이름으로-쿼리-생성)    
🎀 [JPA NamedQuery](#jpa-namedquery)    
🎀 [@Query, 레포지토리 메소드에 쿼리 정의하기](#query-레포지토리-메소드에-쿼리-정의하기)    
🎀 [@Query, 값, DTO 조회하기](#query-값-dto-조회하기)    
🎀 [파라미터 바인딩](#파라미터-바인딩)    
🎀 [반환 타입](#반환-타입)    
🎀 [순수 JPA 페이징과 정렬](#순수-jpa-페이징과-정렬)    
🎀 [스프링 데이터 JPA 페이징과 정렬](#스프링-데이터-jpa-페이징과-정렬)    
🎀 [벌크성 수정 쿼리](#벌크성-수정-쿼리)    
🎀 [@EntityGraph](#entitygraph)    
🎀 [JPA Hint & Lock](#jpa-hint--lock)    

## 쿼리 메소드 기능 3가지
1. 메소드 이름으로 쿼리 생성
2. 메소드 이름으로 JPA NamedQuery 호출
3. `@Query` 애노테이션을 사용해서 `Repository` 인터페이스에 쿼리 직접 정의

## 메소드 이름으로 쿼리 생성
메소드 이름을 분석해서 `JPQL` 쿼리 실행

이름과 나이를 기준으로 회원 조회하기
#### 순수 JPA 레포지토리

```java
public List<Member> findByUsernameAndAgeGreaterThan(String username, int age) {
    em.createQuery("select m from Member m where m.username = :username and m.age > :age")
            .setParameter("username", username)
            .setParameter("age", age)
            .getResultList();
}
```

#### [스프링 데이터 JPA](..%2Fsrc%2Fmain%2Fjava%2Fddangme%2Fspringdatajpa%2Frepository%2FMemberRepository.java)
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    List<Member> findByUsernameAndAgeGreaterThan(String username, int age);
}
```
- 스프링 데이터 JPA는 메소드 이름을 분석해서 JPQL을 생성하고 실행한다.

> 🍀 [쿼리 메소드 필더 조건 공식 문서](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html)

##### 스프링 데이터 JPA가 제공하는 쿼리 메소드 기능
- 조회: find...By, read...By, query...By, get...By
  - 예:) findHelloBy 처럼 ...에 식별하기 위한 내용(설명)이 들어가도 된다. 
- COUNT: count...By 반환타입 `long`
- EXISTS: exists...By 반환타입 `boolean`
- 삭제: delete...By, remove...By 반환타입 `long` 
- DISTINCT: findDistinct, findMemberDistinctBy 
- LIMIT: findFirst3, findFirst, findTop, findTop3

> 🍀 이 기능은 엔티티의 필드명이 변경되면 인터페이스에 정의한 메서드 이름도 꼭 함께 변경해야 한다. 그렇지 않으면 애플리케이션을 실행하는 시점에 오류가 발생한다.  
> 이렇게 애플리케이션 로딩 시점에 오류를 인지할 수 있는 것이 스프링 데이터 JPA의 매우 큰 장점이다.

## JPA NamedQuery
JPA의 `NamedQuery`를 호출할 수 있다.

### [`@NamedQuery` 애노테이션으로 Named 쿼리 정의하기 - Member](..%2Fsrc%2Fmain%2Fjava%2Fddangme%2Fspringdatajpa%2Fentity%2FMember.java)
```java
@Entity
@NamedQuery(
        name = "Member.findByUsername",
        qeury = "SELECT m from Member m WHERE m.username = :username")
public class Member { ... }
```

### JPA를 직접 사용해서 Named 쿼리 호출하기
```java
public class MemberRepository {
    public List<Member> findByUsername(String username) {
         ...
         List<Member> resultList = em.createNamedQuery("Member.findByUsername", Member.class)
                 .setParameter("username", username)
                 .getResultList();
    }
}
```

### [스프링 데이터 JPA로 Named 쿼리 호출 - MemberRepository](..%2Fsrc%2Fmain%2Fjava%2Fddangme%2Fspringdatajpa%2Frepository%2FMemberRepository.java)
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    ...
  
    List<Member> findByUsername(@Param("username") String username);
}
```
스프링 데이터 JPA는 선언한 "도메인 클래스 + .(점) + 메서드 이름"으로 Named 쿼리를 찾아서 실행한다.  
만약 실행할 Named 쿼리가 없으면 메서드 이름으로 쿼리 생성 전략을 사용한다.  
필요한 전략을 변경할 수 있지만, 권장하지 않는다.

> 🍀 스프링 데이터 JPA를 사용하면 실무에서 Named Query를 직접 등록해서 사용하는 일은 드물다.   
> 대신 `@Query`를 사용해서 리포지토리 메소드에 쿼리를 직접 정의한다.

## @Query, 레포지토리 메소드에 쿼리 정의하기
### 메소드에 JPQL 쿼리 작성
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    ...
  
    @Query("SELECT m FROM Member m WHERE m.username= :username AND m.age = :age")
    List<Member> findUser(@Param("username") String username, @Param("age") int age);
}
```

`org.springframework.data.jpa.repository.Query` 애노테이션을 사용한다.  
실행할 메서드에 정적 쿼리를 직접 작성하므로 이름없는 Named 쿼리라고 할 수 있다.  
JPA Named 쿼리 처럼 애프리케이션 실행 시점에 문법 오류를 발견할 수 있다.

> 🍀 실무에서는 메소드 이름으로 쿼리 생성 기능은 파라미터가 증가하면 메서드 이름이 매우 지저분해진다. 따라서 `@Query` 기능을 자주 사용하게 된다.

## @Query, 값, DTO 조회하기
### 단순히 값 하나를 조회하기
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    ...
    
    @Query("SELECT m.username FROM Member m")
    List<String> findUsernameList();
}
```
JPA 값 타입(`@Embedded`)도 이 방식으로 조회할 수 있다.

### DTO로 직접 조회
#### [MemberDTO 생성](..%2Fsrc%2Fmain%2Fjava%2Fddangme%2Fspringdatajpa%2Fdto%2FMemberDTO.java) 
```java
@Data
@AllArgsConstructor
public class MemberDTO {
    Long id;
    String username;
    String teamName;
}
```

#### 레포지토리에 메소드 추가
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    ...
  
    @Query("SELECT new ddangme.springdatajpa.dto.MemberDTO(m.id, m.username, t.name) FROM Member m JOIN m.team t")
    List<MemberDTO> findMemberDTO();
}
```
> 🚨 DTO로 직접 조회하려면 JPA의 `new` 명령어를 사용해야 한다. 그리고 생성자가 맞는 DTO가 필요하다. (JPA와 사용방식이 동일하다.)

## 파라미터 바인딩
## 반환 타입
## 순수 JPA 페이징과 정렬
## 스프링 데이터 JPA 페이징과 정렬
## 벌크성 수정 쿼리
## @EntityGraph
## JPA Hint & Lock